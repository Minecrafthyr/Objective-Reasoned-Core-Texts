# 客观理智标准

目录

- [客观理智标准](#客观理智标准)
  - [精神与认知状态判定](#精神与认知状态判定)
  - [信息分类](#信息分类)
    - [可置信度](#可置信度)
      - [高可置信](#高可置信)
      - [中可置信](#中可置信)
      - [低可置信](#低可置信)
      - [不可置信](#不可置信)
  - [性别分类标准](#性别分类标准)
    - [生物](#生物)
    - [人类](#人类)
  - [客观理智语言标准](#客观理智语言标准)
  - [客观理智编程语言标准](#客观理智编程语言标准)
      - [#1 Print Hello World](#1-print-hello-world)
      - [#2 Print Hello 10 times](#2-print-hello-10-times)
      - [#3 Create a procedure](#3-create-a-procedure)
      - [#4 Create a function](#4-create-a-function)
      - [#5 Create a 2D Point data structure](#5-create-a-2d-point-data-structure)
      - [#6 Iterate over list values](#6-iterate-over-list-values)
      - [#7 Iterate over list indexes and values](#7-iterate-over-list-indexes-and-values)
      - [#8 Create a map (associative array)](#8-create-a-map-associative-array)
      - [#9 Create a Binary Tree data structure](#9-create-a-binary-tree-data-structure)
      - [#10 Shuffle a list](#10-shuffle-a-list)
      - [#11 Pick a random element from a list](#11-pick-a-random-element-from-a-list)
      - [#12 Check if list contains a value](#12-check-if-list-contains-a-value)
      - [#13 Iterate over map keys and values](#13-iterate-over-map-keys-and-values)
      - [#14 Pick uniformly a random floating point number in \[a..b)](#14-pick-uniformly-a-random-floating-point-number-in-ab)

## 精神与认知状态判定

## 信息分类

### 可置信度

描述现实事实、事件的，适用可置信度分类标准。

#### 高可置信

- 有明确迹象证明其发生，且使用去情绪化描述的。

#### 中可置信

- 可置信的官方渠道发布的。

#### 低可置信

- 未经过科学研究全方面证明的。
- 使用情绪引导结论的。
- 使用主观的或定义模糊的词汇的。
- 避重就轻或描述不是同一概念的。

#### 不可置信

- 明确被证伪的。
- 使用没有事实证据的内容煽动情绪的。
- 无资质人员发布未证实的专业领域内容的。
- 宣传无法证明功能有效的产品的。

## 性别分类标准

### 生物

列表有：

- 无
- 雌
- 雄
- 雌雄同体
- 半雌体

参数有：

- 生殖功能：有/无

### 人类

【简】是取性征快速判断的性别，作快速分辨用。  
除【简】外的性别需经医学检验，且不应在无关领域使用。

- 【简】女
- 【简】男

## 客观理智语言标准

0

#0 点、中点、原点（mid）

1

#1 取反 | negate
#2 直 | straight  
#3 端点、边缘、限制 | end  
#4 朝向 | orientation

2

#6 交错（crossing）

- #1#0：无
- #1#0#0：删除点
- #2#0：一维的
- #1#2：收缩
- #1#3：另一端
- #1#0#3：无限
- #3#3：线段、距离、长度
- #1#0 #3#3#0：等于、分割线段
- #1#0#3#2：直线
- #3#1#0#3#2：射线
- #3#3#0：绝对值
- #1#4：负方向
- #1#0 #3#3#4#0：大于，在线段正方向的某点进行分割
- #1#0 #3#3#1#4#0：小于，在线段负方向的某点进行分割
- #5#4：向正方向移动
- #5#1#4：向负方向移动
- #5#4#5#1#4：撕扯

## 客观理智编程语言标准

<details><summary>Compares</summary>


Rust
```rs
let x = 1;
```
C++
```cpp
auto x = 1;
```
Python
```py
x = 1
```
My Idea
```or
1 => x;
```

---

Rust
```rs
fn f_or_1(cond: bool) {
  if cond { f(); }
  if cond { f(); } else { 1 }
}
```
C++
```cpp
auto f_or_1(bool cond) {
  if (cond) f();
  return cond ? f() : 1;
}
```
Python
```py
def f_or_1(cond):
  if cond:
    f()
  return f() if cond else 1
```
My Idea
```or
fn f_or_1(cond) {
  cond -> f();
  cond -> f() |> 1
}
```

---

Rust
```rs
map.get("key").unwrap_or("<unknown>")
```
C++
```cpp
map.find("key") != map.end() ? map["key"] : "<unknown>"
```
Python
```py
map.get("key", "<unknown>")
```
My Idea
```or
map["key"] | "<unknown>"
```

---

Rust
```rs
fn apply(x: &mut Option<i64>) {
  x = f_may_none();
  println!("{x}");
}
```
C++
```cpp
void apply(optional<i64>& x) {
  x = f_may_none();
  println("{}", x);
}
```
Python
```py
def apply(x: i64 | None) {
  x = f_may_none()
  println(f"{x}")
}
```
My Idea
```or
fn apply(x: i64?) {
  println(f"{f_may_none() => x}");
}
```

---

</details>

<details><summary>Idioms</summary>

Used: https://www.programming-idioms.org (CC-BY-SA)


#### #1 [Print Hello World](https://www.programming-idioms.org/idiom/1/print-hello-world)

Print a literal string on standard output

```orc
use std.io.*;
```

```orc
print("Hello World");
```

#### #2 [Print Hello 10 times](https://www.programming-idioms.org/idiom/2/print-hello-10-times)

Loop to execute some code a constant number of times

![Ten lines of Hello](https://storage.googleapis.com/programming-idioms-pictures/idiom/2/Hello_fading.dark.webp)

```orc
use std.io.*;
```

```orc
print("Hello World" * 10);
```

#### #3 [Create a procedure](https://www.programming-idioms.org/idiom/3/create-a-procedure)

Like a function which doesn't return any value, thus has only side effects (e.g. Print to standard output)

```orc
use std.io.*;
```

```orc
fn () { print("") } X;
```

#### #4 [Create a function](https://www.programming-idioms.org/idiom/4/create-a-function)

Create a function which returns the square of an integer

```orc
use std.math.*;
```

```orc
fn square(i: DynInt) {i * i}
```

#### #5 [Create a 2D Point data structure](https://www.programming-idioms.org/idiom/5/create-a-2d-point-data-structure)

Declare a container type for two floating-point numbers x and y

![A point as (x, y) cartesian coordinates](https://storage.googleapis.com/programming-idioms-pictures/idiom/5/2D_point.dark.webp)

```orc
use std.math.*;
```

```orc
type point DynFloat(x, y);
```

or

```orc
use std.shapes.Point2 as Point;
```

#### #6 [Iterate over list values](https://www.programming-idioms.org/idiom/6/iterate-over-list-values)

Do something with each item **_x_** of the list (or array) **_items_**, regardless indexes.

```orc
items each DoSomethingWith;
```

#### #7 [Iterate over list indexes and values](https://www.programming-idioms.org/idiom/7/iterate-over-list-indexes-and-values)

Print each index i with its value x from an array-like collection items

```orc
items.indexed() each DoSomethingWith;
```

#### #8 [Create a map (associative array)](https://www.programming-idioms.org/idiom/8/create-a-map-associative-array)

Create a new map object **_x_**, and provide some (key, value) pairs as initial content.

```orc
use std.container.*
```

```orc
KVMap{ 'x': 1, 'y': 2 } => map;
```

#### #9 [Create a Binary Tree data structure](https://www.programming-idioms.org/idiom/9/create-a-binary-tree-data-structure)

```orc
use std.container.*
```

```orc
struct<T> BinaryTreeNode(T value, Self*? left, Self*? right);
```

#### #10 [Shuffle a list](https://www.programming-idioms.org/idiom/10/shuffle-a-list)

Generate a random permutation of the elements of list **_x_**

```orc
use std.random.*
```

```orc
x.indexed() each i, v {
  [0..x.len).pick => j;
  x[j] <=> v;
}
```

#### #11 [Pick a random element from a list](https://www.programming-idioms.org/idiom/11/pick-a-random-element-from-a-list)

The list **_x_** must be non-empty.

```orc
x.pick;
```

#### #12 [Check if list contains a value](https://www.programming-idioms.org/idiom/12/check-if-list-contains-a-value)

Check if the list contains the value **_x_**.  
**_list_** is an iterable finite container.

[Is this x item contained in this list?](https://storage.googleapis.com/programming-idioms-pictures/idiom/12/list_contains.dark.webp)

```orc
list.find(x);
```

#### #13 Iterate over map keys and values

Access each key **_k_** with its value **_x_** from an associative array **_mymap_**, and print them.

```orc
use std.io.*
```

```orc
mymap each k, x { Print(fmt"{k}, {x}"); }
```

#### #14 Pick uniformly a random floating point number in [a..b)

Pick a random number greater than or equals to **_a_**, strictly inferior to **_b_**.  
Precondition : **_a_** < **_b_**.


```orc
use std.random.*
```

```orc
[a..b).pick
```


</details>